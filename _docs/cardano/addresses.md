---
layout: default
title: Addresses in Cardano SL
permalink: /cardano/addresses/
group: cardano
---

# Addresses in Cardano SL

To send and receive value, addresses are used in virtually any cryptocurrency.

## How Does an Address Look Like?

In Cardano, we adopt Bitcoin way of encoding the address. It's called
“Base 58” because it uses 58-symbol alphabet to encode data. Here is the
alphabet we are using
`123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`. Notably,
it avoids both non-alphanumeric characters and letters which might look
ambiguous when printed. It is therefore designed for human users who
manually enter the data, copying from some visual source, but also
allows easy copy and paste because a double-click will usually select
the whole string. We also adopt a way to make sure that an address is
entered correctly by appending a 32-bit Cyclic Redundancy Code checksum
(CRC32) to the end of the part of the address which encodes public key
or script hash. This way, full address is generated by the following
rule, where `<>` is a concatenation operator:
`toBase58(addr<>crc32(addr))`.

An example of a valid address is

```
1EWYSJnvgnSUmp8Gi4mADvU2zkJgVAA7McgFRXiqwDBs8
```

## Public Key Addresses

As we have discussed in the [Introduction](/#you-own-your-money), the
wallets you see in the user interface are a convenient representation of
the fact that you own a secret key to spend money in this particular
wallet. But how such spending is verified by the network and how can you
receive money from others? The answer is that along with the secret key
which is used to control the value in your wallets, a public key is
generated and encoded in Base58. This public component can be known by
anybody, hence the name. Public key mostly serves two purposes:

 1. When you create a transaction, anyone with the corresponding public
    key can verify that you indeed control secret key.
 2. When someone wants to send you the money, they use your public key
    encoded in Base58 as the address.

Public key is also used to verify some protocol messages that have to be
signed with the secret key.

As we have discussed before, address is exactly the public hash key plus
CRC32, encoded in Base58.

## Pay to Script Hash

Interestingly, Cardano SL also supports Pay to Script Hash transactions,
more often referred to as P2SH transactions, or just “P2SH”. The idea of
P2SH is to provide a lot of flexibility to formulating complex rules for
spending money. Instead of sending a transaction to a public key
address, we create a validator script into which redemption script can
be plugged in. To redeem funds, we evaluate validator script with
redemption script as an argument. If validator script evaluates to
`success`, money is getting sent as specified by the redeemer.
Otherwise, nothing happens.

To quote Bitcoin Wiki,

> Using P2SH, you can send bitcoins to an address that is secured in
> various unusual ways without knowing anything about the details of how
> the security is set up. The recipient might need the signatures of
> several people to spend these bitcoins, or a password might be
> required, or the requirements could be completely unique.

## Advanced Topics

### Hashing

For a number of reasons, it is useful to have fixed-length
representation of arbitrary data, for example, when we're working with
P2SH, we want validator scripts of arbitrary length to be hashed in a
P2SH address of the same length that is easy to type in and operate
with. Also, in order to have an authenticated data structure capturing
information stored on the blockchain, we have to have the same kind of
primitive. The requirements on such a function are manyfold:

 1. On the same input data it always returns the same output string
 2. It is computationally simple to calculate output for a given input
 3. It is computationally complex to reverse the process
 4. A small change in input produces big change in output
 5. It is computationally complex to find two pieces of input data that
    produce the same output

The way we transform arbitrary input into output, complying with (1-5)
is called “a cryptographic hash function”.

We are currently using two hash functions: `SHA3` with 256 digest and
`BLAKE2S` with 224 bit digest.

For example, for addresses, we wrap SHA3 digest into BLAKE2s, as shown
in the code snippet below.

~~~ haskell
type AddressHash = AbstractHash Blake2s_224

addressHash :: Bi a => a -> AddressHash b
adressHash = AbstractHash . secondHash . firstHash
  where
    firstHash :: Bi a => a -> Digest SHA3_256
    firstHash = hashlazy . Bi.encode
    secondHash :: Digest SHA3_256 -> Digest Blake2s_224
    secondHash = CryptoHash.hash
~~~
